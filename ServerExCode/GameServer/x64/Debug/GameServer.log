  #pragma once
  #include "Protocol.pb.h"
  
  using PacketHandlerFunc = std::function<bool(PacketSessionRef&, BYTE*, int32)>;
  extern PacketHandlerFunc GPacketHandler[UINT16_MAX];
  
  enum : uint16
  {
  	PKT_C_LOGIN = 1000,
  	PKT_C_MOVE = 1001,
  	PKT_C_ROOM_CREATE = 1002,
  	PKT_C_ROOM_DATA = 1003,
  	PKT_C_ROOM_REQUEST = 1004,
  	PKT_C_ROOM_PLAYER_LIST_REQUEST = 1005,
  	PKT_C_START_GAME = 1006,
  	PKT_C_ATTACK = 1007,
  	PKT_C_RTT_PING = 1008,
  	PKT_S_RTT_PONG = 1009,
  	PKT_S_LOGIN = 1010,
  	PKT_S_ROOM_LOBBY = 1011,
  	PKT_S_LOBBY_PLAYER_INFO = 1012,
  	PKT_S_GAME_START = 1013,
  	PKT_S_ROOM_DATA = 1014,
  	PKT_S_ROOM_RESPONSE = 1015,
  	PKT_S_MOVE = 1016,
  	PKT_S_OBJECT_SPAWN = 1017,
  	PKT_S_OBJECT_DEAD = 1018,
  	PKT_S_OBJECT_DAMAGE = 1019,
  };
  
  // Custom Handlers
  bool Handle_INVALID(PacketSessionRef& session, BYTE* buffer, int32 len);
  bool Handle_C_LOGIN(PacketSessionRef& session, Protocol::C_LOGIN& pkt);
  bool Handle_C_MOVE(PacketSessionRef& session, Protocol::C_MOVE& pkt);
  bool Handle_C_ROOM_CREATE(PacketSessionRef& session, Protocol::C_ROOM_CREATE& pkt);
  bool Handle_C_ROOM_DATA(PacketSessionRef& session, Protocol::C_ROOM_DATA& pkt);
  bool Handle_C_ROOM_REQUEST(PacketSessionRef& session, Protocol::C_ROOM_REQUEST& pkt);
  bool Handle_C_ROOM_PLAYER_LIST_REQUEST(PacketSessionRef& session, Protocol::C_ROOM_PLAYER_LIST_REQUEST& pkt);
  bool Handle_C_START_GAME(PacketSessionRef& session, Protocol::C_START_GAME& pkt);
  bool Handle_C_ATTACK(PacketSessionRef& session, Protocol::C_ATTACK& pkt);
  bool Handle_C_RTT_PING(PacketSessionRef& session, Protocol::C_RTT_PING& pkt);
  
  class ClientPacketHandler
  {
  public:
  	static void Init()
  	{
  		for (int32 i = 0; i < UINT16_MAX; i++)
  			GPacketHandler[i] = Handle_INVALID;
  		GPacketHandler[PKT_C_LOGIN] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_LOGIN>(Handle_C_LOGIN, session, buffer, len); };
  		GPacketHandler[PKT_C_MOVE] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_MOVE>(Handle_C_MOVE, session, buffer, len); };
  		GPacketHandler[PKT_C_ROOM_CREATE] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_ROOM_CREATE>(Handle_C_ROOM_CREATE, session, buffer, len); };
  		GPacketHandler[PKT_C_ROOM_DATA] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_ROOM_DATA>(Handle_C_ROOM_DATA, session, buffer, len); };
  		GPacketHandler[PKT_C_ROOM_REQUEST] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_ROOM_REQUEST>(Handle_C_ROOM_REQUEST, session, buffer, len); };
  		GPacketHandler[PKT_C_ROOM_PLAYER_LIST_REQUEST] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_ROOM_PLAYER_LIST_REQUEST>(Handle_C_ROOM_PLAYER_LIST_REQUEST, session, buffer, len); };
  		GPacketHandler[PKT_C_START_GAME] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_START_GAME>(Handle_C_START_GAME, session, buffer, len); };
  		GPacketHandler[PKT_C_ATTACK] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_ATTACK>(Handle_C_ATTACK, session, buffer, len); };
  		GPacketHandler[PKT_C_RTT_PING] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::C_RTT_PING>(Handle_C_RTT_PING, session, buffer, len); };
  	}
  
  	static bool HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len)
  	{
  		PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);
  		return GPacketHandler[header->id](session, buffer, len);
  	}
  	static SendBufferRef MakeSendBuffer(Protocol::S_RTT_PONG& pkt) { return MakeSendBuffer(pkt, PKT_S_RTT_PONG); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_LOGIN& pkt) { return MakeSendBuffer(pkt, PKT_S_LOGIN); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_ROOM_LOBBY& pkt) { return MakeSendBuffer(pkt, PKT_S_ROOM_LOBBY); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_LOBBY_PLAYER_INFO& pkt) { return MakeSendBuffer(pkt, PKT_S_LOBBY_PLAYER_INFO); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_GAME_START& pkt) { return MakeSendBuffer(pkt, PKT_S_GAME_START); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_ROOM_DATA& pkt) { return MakeSendBuffer(pkt, PKT_S_ROOM_DATA); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_ROOM_RESPONSE& pkt) { return MakeSendBuffer(pkt, PKT_S_ROOM_RESPONSE); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_MOVE& pkt) { return MakeSendBuffer(pkt, PKT_S_MOVE); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_OBJECT_SPAWN& pkt) { return MakeSendBuffer(pkt, PKT_S_OBJECT_SPAWN); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_OBJECT_DEAD& pkt) { return MakeSendBuffer(pkt, PKT_S_OBJECT_DEAD); }
  	static SendBufferRef MakeSendBuffer(Protocol::S_OBJECT_DAMAGE& pkt) { return MakeSendBuffer(pkt, PKT_S_OBJECT_DAMAGE); }
  
  private:
  	template<typename PacketType, typename ProcessFunc>
  	static bool HandlePacket(ProcessFunc func, PacketSessionRef& session, BYTE* buffer, int32 len)
  	{
  		PacketType pkt;
  		if (pkt.ParseFromArray(buffer + sizeof(PacketHeader), len - sizeof(PacketHeader)) == false)
  			return false;
  
  		return func(session, pkt);
  	}
  
  	template<typename T>
  	static SendBufferRef MakeSendBuffer(T& pkt, uint16 pktId)
  	{
  		const uint16 dataSize = static_cast<uint16>(pkt.ByteSizeLong());
  		const uint16 packetSize = dataSize + sizeof(PacketHeader);
  
  		SendBufferRef sendBuffer = GSendBufferManager->Open(packetSize);
  		PacketHeader* header = reinterpret_cast<PacketHeader*>(sendBuffer->Buffer());
  		header->size = packetSize;
  		header->id = pktId;
  		ASSERT_CRASH(pkt.SerializeToArray(&header[1], dataSize));
  		sendBuffer->Close(packetSize);
  
  		return sendBuffer;
  	}
  };
  #pragma once
  #include "Protocol.pb.h"
  
  using PacketHandlerFunc = std::function<bool(PacketSessionRef&, BYTE*, int32)>;
  extern PacketHandlerFunc GPacketHandler[UINT16_MAX];
  
  enum : uint16
  {
  	PKT_C_LOGIN = 1000,
  	PKT_C_MOVE = 1001,
  	PKT_C_ROOM_CREATE = 1002,
  	PKT_C_ROOM_DATA = 1003,
  	PKT_C_ROOM_REQUEST = 1004,
  	PKT_C_ROOM_PLAYER_LIST_REQUEST = 1005,
  	PKT_C_START_GAME = 1006,
  	PKT_C_ATTACK = 1007,
  	PKT_C_RTT_PING = 1008,
  	PKT_S_RTT_PONG = 1009,
  	PKT_S_LOGIN = 1010,
  	PKT_S_ROOM_LOBBY = 1011,
  	PKT_S_LOBBY_PLAYER_INFO = 1012,
  	PKT_S_GAME_START = 1013,
  	PKT_S_ROOM_DATA = 1014,
  	PKT_S_ROOM_RESPONSE = 1015,
  	PKT_S_MOVE = 1016,
  	PKT_S_OBJECT_SPAWN = 1017,
  	PKT_S_OBJECT_DEAD = 1018,
  	PKT_S_OBJECT_DAMAGE = 1019,
  };
  
  // Custom Handlers
  bool Handle_INVALID(PacketSessionRef& session, BYTE* buffer, int32 len);
  bool Handle_S_RTT_PONG(PacketSessionRef& session, Protocol::S_RTT_PONG& pkt);
  bool Handle_S_LOGIN(PacketSessionRef& session, Protocol::S_LOGIN& pkt);
  bool Handle_S_ROOM_LOBBY(PacketSessionRef& session, Protocol::S_ROOM_LOBBY& pkt);
  bool Handle_S_LOBBY_PLAYER_INFO(PacketSessionRef& session, Protocol::S_LOBBY_PLAYER_INFO& pkt);
  bool Handle_S_GAME_START(PacketSessionRef& session, Protocol::S_GAME_START& pkt);
  bool Handle_S_ROOM_DATA(PacketSessionRef& session, Protocol::S_ROOM_DATA& pkt);
  bool Handle_S_ROOM_RESPONSE(PacketSessionRef& session, Protocol::S_ROOM_RESPONSE& pkt);
  bool Handle_S_MOVE(PacketSessionRef& session, Protocol::S_MOVE& pkt);
  bool Handle_S_OBJECT_SPAWN(PacketSessionRef& session, Protocol::S_OBJECT_SPAWN& pkt);
  bool Handle_S_OBJECT_DEAD(PacketSessionRef& session, Protocol::S_OBJECT_DEAD& pkt);
  bool Handle_S_OBJECT_DAMAGE(PacketSessionRef& session, Protocol::S_OBJECT_DAMAGE& pkt);
  
  class ServerPacketHandler
  {
  public:
  	static void Init()
  	{
  		for (int32 i = 0; i < UINT16_MAX; i++)
  			GPacketHandler[i] = Handle_INVALID;
  		GPacketHandler[PKT_S_RTT_PONG] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_RTT_PONG>(Handle_S_RTT_PONG, session, buffer, len); };
  		GPacketHandler[PKT_S_LOGIN] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_LOGIN>(Handle_S_LOGIN, session, buffer, len); };
  		GPacketHandler[PKT_S_ROOM_LOBBY] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_ROOM_LOBBY>(Handle_S_ROOM_LOBBY, session, buffer, len); };
  		GPacketHandler[PKT_S_LOBBY_PLAYER_INFO] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_LOBBY_PLAYER_INFO>(Handle_S_LOBBY_PLAYER_INFO, session, buffer, len); };
  		GPacketHandler[PKT_S_GAME_START] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_GAME_START>(Handle_S_GAME_START, session, buffer, len); };
  		GPacketHandler[PKT_S_ROOM_DATA] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_ROOM_DATA>(Handle_S_ROOM_DATA, session, buffer, len); };
  		GPacketHandler[PKT_S_ROOM_RESPONSE] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_ROOM_RESPONSE>(Handle_S_ROOM_RESPONSE, session, buffer, len); };
  		GPacketHandler[PKT_S_MOVE] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_MOVE>(Handle_S_MOVE, session, buffer, len); };
  		GPacketHandler[PKT_S_OBJECT_SPAWN] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_OBJECT_SPAWN>(Handle_S_OBJECT_SPAWN, session, buffer, len); };
  		GPacketHandler[PKT_S_OBJECT_DEAD] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_OBJECT_DEAD>(Handle_S_OBJECT_DEAD, session, buffer, len); };
  		GPacketHandler[PKT_S_OBJECT_DAMAGE] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_OBJECT_DAMAGE>(Handle_S_OBJECT_DAMAGE, session, buffer, len); };
  	}
  
  	static bool HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len)
  	{
  		PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);
  		return GPacketHandler[header->id](session, buffer, len);
  	}
  	static SendBufferRef MakeSendBuffer(Protocol::C_LOGIN& pkt) { return MakeSendBuffer(pkt, PKT_C_LOGIN); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_MOVE& pkt) { return MakeSendBuffer(pkt, PKT_C_MOVE); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_ROOM_CREATE& pkt) { return MakeSendBuffer(pkt, PKT_C_ROOM_CREATE); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_ROOM_DATA& pkt) { return MakeSendBuffer(pkt, PKT_C_ROOM_DATA); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_ROOM_REQUEST& pkt) { return MakeSendBuffer(pkt, PKT_C_ROOM_REQUEST); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_ROOM_PLAYER_LIST_REQUEST& pkt) { return MakeSendBuffer(pkt, PKT_C_ROOM_PLAYER_LIST_REQUEST); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_START_GAME& pkt) { return MakeSendBuffer(pkt, PKT_C_START_GAME); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_ATTACK& pkt) { return MakeSendBuffer(pkt, PKT_C_ATTACK); }
  	static SendBufferRef MakeSendBuffer(Protocol::C_RTT_PING& pkt) { return MakeSendBuffer(pkt, PKT_C_RTT_PING); }
  
  private:
  	template<typename PacketType, typename ProcessFunc>
  	static bool HandlePacket(ProcessFunc func, PacketSessionRef& session, BYTE* buffer, int32 len)
  	{
  		PacketType pkt;
  		if (pkt.ParseFromArray(buffer + sizeof(PacketHeader), len - sizeof(PacketHeader)) == false)
  			return false;
  
  		return func(session, pkt);
  	}
  
  	template<typename T>
  	static SendBufferRef MakeSendBuffer(T& pkt, uint16 pktId)
  	{
  		const uint16 dataSize = static_cast<uint16>(pkt.ByteSizeLong());
  		const uint16 packetSize = dataSize + sizeof(PacketHeader);
  
  		SendBufferRef sendBuffer = GSendBufferManager->Open(packetSize);
  		PacketHeader* header = reinterpret_cast<PacketHeader*>(sendBuffer->Buffer());
  		header->size = packetSize;
  		header->id = pktId;
  		ASSERT_CRASH(pkt.SerializeToArray(&header[1], dataSize));
  		sendBuffer->Close(packetSize);
  
  		return sendBuffer;
  	}
  };
  C:Enum.pb.h
  1개 파일이 복사되었습니다.
  C:Enum.pb.cc
  1개 파일이 복사되었습니다.
  C:Struct.pb.h
  1개 파일이 복사되었습니다.
  C:Struct.pb.cc
  1개 파일이 복사되었습니다.
  C:Protocol.pb.h
  1개 파일이 복사되었습니다.
  C:Protocol.pb.cc
  1개 파일이 복사되었습니다.
  C:ClientPacketHandler.h
  1개 파일이 복사되었습니다.
  C:Enum.cs
  1개 파일이 복사되었습니다.
  C:Struct.cs
  1개 파일이 복사되었습니다.
  C:Protocol.cs
  1개 파일이 복사되었습니다.
  계속하려면 아무 키나 누르십시오 . . . 
  Building.cpp
  ClientPacketHandler.cpp
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\ClientPacketHandler.cpp(30,65): warning C4244: '인수': 'google::protobuf::uint64'에서 'const int'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  (소스 파일 '/ClientPacketHandler.cpp'을(를) 컴파일하는 중)
  
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\ClientPacketHandler.cpp(32,64): warning C4244: '인수': 'google::protobuf::uint64'에서 'int'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  (소스 파일 '/ClientPacketHandler.cpp'을(를) 컴파일하는 중)
  
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\ClientPacketHandler.cpp(36,43): warning C4244: '인수': 'google::protobuf::uint64'에서 'int'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  (소스 파일 '/ClientPacketHandler.cpp'을(를) 컴파일하는 중)
  
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\ClientPacketHandler.cpp(83,13): warning C4244: '초기화 중': 'google::protobuf::uint64'에서 'int'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  (소스 파일 '/ClientPacketHandler.cpp'을(를) 컴파일하는 중)
  
  GameObject.cpp
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\GameObject.cpp(225,13): warning C4244: '=': 'float'에서 'int'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  (소스 파일 '/GameObject.cpp'을(를) 컴파일하는 중)
  
  GameServer.cpp
  GameSession.cpp
  GameSessionManager.cpp
  Grid.cpp
  ProtossUnit.cpp
  Room.cpp
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(39,31): warning C4244: '인수': '_Ty'에서 'float'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(39,31): warning C4244:         with
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(39,31): warning C4244:         [
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(39,31): warning C4244:             _Ty=int
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(39,31): warning C4244:         ]
  (소스 파일 '/Room.cpp'을(를) 컴파일하는 중)
      C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(39,31):
      템플릿 인스턴스화 컨텍스트(가장 오래된 인스턴스화 컨텍스트)가
          C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Room.cpp(61,9):
          컴파일되는 함수 템플릿 인스턴스화 'std::shared_ptr<GridManager> MakeShared<GridManager,int,int,int,int>(int &&,int &&,int &&,int &&)'에 대한 참조를 확인하세요.
          C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\ServerCore\Memory.h(53,27):
          컴파일되는 함수 템플릿 인스턴스화 'Type *xnew<GridManager,_Ty,_Ty,_Ty,_Ty>(_Ty &&,_Ty &&,_Ty &&,_Ty &&)'에 대한 참조를 확인하세요.
          with
          [
              Type=GridManager,
              _Ty=int
          ]
  
  RoomManager.cpp
  Unit.cpp
  코드를 생성하고 있습니다...
  Enum.pb.cc
  Protocol.pb.cc
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(821,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(1104,67): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(1560,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(1786,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(1976,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(2194,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(3139,67): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(3146,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(3626,77): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(3636,80): warning C4244: '인수': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Protocol.pb.cc(4064,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  Struct.pb.cc
C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\GameServer\Struct.pb.cc(526,70): warning C4244: '=': 'google::protobuf::uint64'에서 'google::protobuf::int32'(으)로 변환하면서 데이터가 손실될 수 있습니다.
  코드를 생성하고 있습니다...
  LINK : 이전 연결 이후로 0개의 새 모듈과 14개(전체 89개 중)의 모듈이 변경되었습니다.
  라이브러리를 검색하고 있습니다.
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\kernel32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\user32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\gdi32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\winspool.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\comdlg32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\advapi32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\shell32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\ole32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\oleaut32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\uuid.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\odbc32.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\odbccp32.lib 검색 중:
      C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\Libraries\Libs\ServerCore\Debug\ServerCore.lib 검색 중:
      C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\Libraries\Libs\Protobuf\Debug\libprotobufd.lib 검색 중:
      C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\lib\x64\msvcprtd.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\um\x64\ws2_32.lib 검색 중:
      C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\lib\x64\MSVCRTD.lib 검색 중:
      C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\lib\x64\OLDNAMES.lib 검색 중:
      C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\lib\x64\vcruntimed.lib 검색 중:
      C:\Program Files (x86)\Windows Kits\10\lib\10.0.22621.0\ucrt\x64\ucrtd.lib 검색 중:
        __imp_sqrtf을(를) 찾았습니다.
          GameObject.obj에서 참조됩니다.
          ucrtd.lib(ucrtbased.dll)을(를) 로드했습니다.
  라이브러리가 검색되었습니다.
  Pass 2를 시작하고 있습니다.
       Unit.obj
       Struct.pb.obj
       RoomManager.obj
       Room.obj
       ProtossUnit.obj
       Grid.obj
       ClientPacketHandler.obj
       Protocol.pb.obj
       GameSessionManager.obj
       GameSession.obj
       GameServer.obj
       GameObject.obj
       Enum.pb.obj
       Building.obj
       ServerCore.lib(CoreGlobal.obj)
       MSVCRTD.lib(loadcfg.obj)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
       ucrtd.lib(ucrtbased.dll)
  Pass 2가 끝났습니다.
  GameServer.vcxproj -> C:\Users\hj577\Documents\GitHub\StarCraft-IOCP\ServerExCode\Binary\Debug\GameServer.exe
